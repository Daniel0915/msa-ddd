# 커스텀 예외 및 응답 처리 가이드

## 1. 왜 커스텀 예외가 필요한가?

Java의 기본 예외(`RuntimeException`, `IllegalArgumentException` 등)만으로는 **비즈니스 의미**를 전달하기 어렵다.
HTTP 상태 코드와 비즈니스 에러 코드를 함께 전달하여 클라이언트가 정확히 대응할 수 있게 한다.

---

## 2. 현재 프로젝트 구조

```
standard/
└── resultType/
    └── ResultType.java         ← 응답 표준 인터페이스

global/
├── excepton/
│   └── DomainException.java    ← 도메인 전용 예외
└── reData/
    └── RsData.java             ← 표준 응답 래퍼
```

---

## 3. ResultType 인터페이스

```java
public interface ResultType {
    String getResultCode();   // "201-1", "409-1" 등

    String getMsg();          // 사용자 메시지

    default <T> T getData() { // 응답 데이터 (옵션)
        return null;
    }
}
```

**역할:**
- 성공 응답(`RsData`)과 실패 응답(`DomainException`) 모두 같은 인터페이스를 구현
- 통일된 응답 형식을 강제

### resultCode 규칙

```
"201-1"  →  HTTP 201 Created + 첫 번째 케이스
"409-1"  →  HTTP 409 Conflict + 첫 번째 케이스
"404-1"  →  HTTP 404 Not Found + 첫 번째 케이스
```

- 앞 3자리: HTTP 상태 코드 의미
- 뒤 숫자: 같은 상태 코드 내 세부 케이스 구분

---

## 4. DomainException (도메인 예외)

```java
@Getter
public class DomainException extends RuntimeException {
    private final String resultCode;
    private final String msg;

    public DomainException(String resultCode, String msg) {
        super(resultCode + " : " + msg);
        this.resultCode = resultCode;
        this.msg = msg;
    }
}
```

### 특징

| 특징 | 설명 |
|------|------|
| `RuntimeException` 상속 | Unchecked 예외 → try-catch 강제하지 않음 |
| `resultCode` | HTTP 상태코드 기반 에러 코드 |
| `msg` | 사용자에게 보여줄 메시지 |
| `super(...)` | 로그에 코드+메시지가 함께 출력됨 |

### 사용 예시

```java
// MemberJoinCase.java
public RsData<Member> join(String username, String password, String nickname) {
    memberRepository.findByUsername(username).ifPresent(_ -> {
        throw new DomainException("409-1", "이미 존재하는 username 입니다.");
    });
    // ...
}
```

- **비즈니스 규칙 위반** 시 즉시 예외 발생
- `resultCode`로 어떤 종류의 에러인지 식별 가능
- `_` (unnamed variable): Java 22+ 문법, 사용하지 않는 변수 표시

---

## 5. RsData (표준 응답 래퍼)

```java
@AllArgsConstructor
@Getter
public class RsData<T> implements ResultType {
    private final String resultCode;
    private final String msg;
    private final T data;

    // data 없는 응답용 생성자
    public RsData(String resultCode, String msg) {
        this(resultCode, msg, null);
    }
}
```

### 사용 예시

```java
// 성공 응답 (데이터 포함)
return new RsData<>("201-1", "%d번 회원이 생성되었습니다.".formatted(member.getId()), member);

// 성공 응답 (데이터 없음)
return new RsData<>("200-1", "처리 완료");
```

### 제네릭 `<T>` 활용

```java
RsData<Member>  rsData = memberFacade.join("user1", "pass", "nick");
Member member   = rsData.getData();      // Member 타입으로 바로 사용
String msg      = rsData.getMsg();       // "1번 회원이 생성되었습니다."
String code     = rsData.getResultCode(); // "201-1"
```

---

## 6. 예외 흐름도

```
[Controller] → [Facade] → [UseCase] → 비즈니스 규칙 위반 감지
                                            ↓
                                   throw DomainException("409-1", "...")
                                            ↓
                          ← ← ← ← ← 예외가 호출 스택을 타고 올라감
                                            ↓
                               [GlobalExceptionHandler]  (향후 구현)
                                            ↓
                               HTTP 409 + { resultCode, msg }
```

---

## 7. 일반 예외 vs DomainException 비교

### 일반 예외

```java
// 문제: 예외 종류만으로 HTTP 코드를 알 수 없음
throw new IllegalArgumentException("이미 존재하는 username 입니다.");
// → 어떤 HTTP 코드로 응답해야 할지 모호함
```

### DomainException

```java
// 해결: 코드에 의미가 담겨있음
throw new DomainException("409-1", "이미 존재하는 username 입니다.");
// → 409 Conflict 응답임을 명확히 알 수 있음
```

---

## 8. 성공/실패 응답 통일

```java
// 성공 시
RsData<Member> success = new RsData<>("201-1", "회원 생성됨", member);
// → resultCode: "201-1", msg: "회원 생성됨", data: Member 객체

// 실패 시 (예외 → ExceptionHandler에서 변환)
DomainException fail = new DomainException("409-1", "중복 username");
// → resultCode: "409-1", msg: "중복 username", data: null
```

둘 다 `ResultType` 인터페이스를 구현하므로 **동일한 형식**으로 클라이언트에 전달 가능하다.

---

## 9. Checked vs Unchecked 예외

### Checked Exception (검사 예외)

```java
public class IOException extends Exception { }
// → 반드시 try-catch 또는 throws 필요
// → 비즈니스 로직에서 사용하면 코드가 복잡해짐
```

### Unchecked Exception (비검사 예외) ← DomainException

```java
public class DomainException extends RuntimeException { }
// → try-catch 강제하지 않음
// → 글로벌 핸들러에서 한 번에 처리
// → Spring @Transactional 기본 롤백 대상
```

**DomainException이 RuntimeException을 상속하는 이유:**
1. `@Transactional`에서 자동 롤백됨
2. 매번 try-catch를 작성하지 않아도 됨
3. 글로벌 예외 핸들러에서 일괄 처리 가능

---

## 10. 핵심 정리

1. `ResultType`: 성공/실패 응답의 **공통 인터페이스**
2. `DomainException`: 비즈니스 규칙 위반 시 사용하는 **도메인 전용 예외**
3. `RsData<T>`: 성공 응답을 감싸는 **제네릭 래퍼**
4. `resultCode`: HTTP 상태코드 기반으로 에러를 **코드화**
5. `RuntimeException` 상속으로 **선언적 롤백**과 **글로벌 예외 처리**를 지원
